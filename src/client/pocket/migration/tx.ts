// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: pocket/migration/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { Application } from "../application/types";
import { ApplicationServiceConfig, SupplierServiceConfig } from "../shared/service";
import { Supplier } from "../shared/supplier";
import { MorseAccountState } from "./morse_onchain";
import { Params } from "./params";

export const protobufPackage = "pocket.migration";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

/** MsgImportMorseClaimableAccounts is used to create the on-chain MorseClaimableAccounts ONLY AND EXACTLY ONCE (per network / re-genesis). */
export interface MsgImportMorseClaimableAccounts {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** the account state derived from the Morse state export and the `pocketd tx migration collect-morse-accounts` command. */
  morseAccountState:
    | MorseAccountState
    | undefined;
  /**
   * Additional documentation:
   * - pocket util export-genesis-for-migration --help
   * - pocketd tx migration collect-morse-accounts --help
   */
  morseAccountStateHash: Uint8Array;
}

/**
 * MsgImportMorseClaimableAccountsResponse is returned from MsgImportMorseClaimableAccounts.
 * It indicates the canonical hash of the imported MorseAccountState, and the number of claimable accounts which were imported.
 */
export interface MsgImportMorseClaimableAccountsResponse {
  /** On-chain computed sha256 hash of the morse_account_state provided in the corresponding MsgCreateMorseAccountState. */
  stateHash: Uint8Array;
  /** Number of claimable accounts (EOAs) collected from Morse state export. */
  numAccounts: number;
}

/**
 * MsgClaimMorseAccount is used to execute a claim (one-time minting of tokens on Shannon),
 * of the balance of the given Morse account, according to the on-chain MorseClaimableAccounts,
 * to the balance of the given Shannon account.
 *
 * NOTE:
 * - The Shannon account specified must be the message signer
 * - Authz grants MAY be used to delegate claiming authority to other Shannon accounts
 */
export interface MsgClaimMorseAccount {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
   * claim messages AND has EXACTLY ONE signer.
   */
  shannonSigningAddress: string;
  /** The bech32-encoded address of the Shannon account to which the claimed balance will be minted. */
  shannonDestAddress: string;
  /** The ed25519 public key of the morse account with morse_src_address. */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, by the Morse account, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
   */
  morseSignature: Uint8Array;
}

/**
 * MsgClaimMorseAccountResponse is returned from MsgClaimMorseAccount.
 * It indicates the morse_src_address of the account which was claimed, the total
 * balance claimed, and the height at which the claim was committed.
 */
export interface MsgClaimMorseAccountResponse {
  /**
   * The hex-encoded address of the Morse account whose balance will be claimed.
   * E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
   */
  morseSrcAddress: string;
  /** The balance which was claimed. */
  claimedBalance:
    | Coin
    | undefined;
  /** The session end height (on Shannon) in which the claim was committed (i.e. claimed). */
  sessionEndHeight: number;
}

/**
 * MsgClaimMorseApplication is used to execute a claim (one-time minting of tokens on Shannon),
 * of the total tokens owned by the given Morse account, according to the on-chain MorseClaimableAccounts,
 * to the balance of the given Shannon account, followed by staking that Shannon account as an application
 * for the given service_config and the same stake amount as on Morse.
 */
export interface MsgClaimMorseApplication {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
   * claim messages AND has EXACTLY ONE signer.
   */
  shannonSigningAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which the claimed tokens
   * will be minted and from which the application will be staked.
   */
  shannonDestAddress: string;
  /** The ed25519 public key of the morse account with morse_src_address. */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, by the Morse account, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
   */
  morseSignature: Uint8Array;
  /**
   * The services this application is staked to request service for.
   * NOTE: This is not a repeated field, as in MsgStakeApplication,
   * because an application can only be staked for one service.
   */
  serviceConfig: ApplicationServiceConfig | undefined;
}

/**
 * MsgClaimMorseApplicationResponse is returned from MsgClaimMorseApplication.
 * It indicates the morse_src_address of the account which was claimed, the unstaked
 * balance claimed, the application stake, and the height at which the claim was committed.
 */
export interface MsgClaimMorseApplicationResponse {
  /** The hex-encoded address of the Morse account whose balance will be claimed. */
  morseSrcAddress: string;
  /** The unstaked balance which was claimed. */
  claimedBalance:
    | Coin
    | undefined;
  /**
   * The stake of the application which was staked as a result of the claim.
   * If the application was already staked, this amount does not include the initial stake (i.e. only the portion which was "claimed").
   */
  claimedApplicationStake:
    | Coin
    | undefined;
  /** The session end height (on Shannon) in which the claim was committed (i.e. claimed). */
  sessionEndHeight: number;
  /** The application which was staked as a result of the claim. */
  application: Application | undefined;
}

/**
 * MsgClaimMorseSupplier is used to:
 * - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
 * - Use the on-chain MorseClaimableAccounts for verification
 * - Credit the minted tokens to the balance of the given Shannon account
 * - Automatically stake that Shannon account as a supplier
 *
 * NOTE: The supplier module's staking fee parameter (at the time of claiming) is deducted from the
 * claimed balance.
 */
export interface MsgClaimMorseSupplier {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
   * claim messages AND has EXACTLY ONE signer.
   */
  shannonSigningAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which the claimed tokens
   * will be minted and which become the supplier owner.
   * See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
   */
  shannonOwnerAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which will become the supplier operator.
   * If empty, the shannon_owner_address will be used.
   * See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
   */
  shannonOperatorAddress: string;
  /** The ed25519 public key of the morse account with morse_src_address. */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, by the Morse account, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
   *
   * TODO_MAINNET(@bryanchriswhite, #1126): Rename to `morse_src_owner_signature`.
   */
  morseSignature: Uint8Array;
  /** The services this supplier is staked to provide service for. */
  services: SupplierServiceConfig[];
}

/**
 * MsgClaimMorseSupplierResponse is returned from MsgClaimMorseSupplier.
 * It indicates:
 * - The morse_src_address of the claimed account
 * - The unstaked balance claimed
 * - The session end height in which the claim was committed
 * - The staked supplier
 */
export interface MsgClaimMorseSupplierResponse {
  /**
   * The hex-encoded address of the Morse account whose balance was claimed.
   * E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
   */
  morseSrcAddress: string;
  /** The unstaked balance which was claimed. */
  claimedBalance: Coin | undefined;
  claimedSupplierStake:
    | Coin
    | undefined;
  /** The session end height (on Shannon) in which the claim was committed (i.e. claimed). */
  sessionEndHeight: number;
  /** The supplier which was staked as a result of the claim. */
  supplier: Supplier | undefined;
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgImportMorseClaimableAccounts(): MsgImportMorseClaimableAccounts {
  return { authority: "", morseAccountState: undefined, morseAccountStateHash: new Uint8Array(0) };
}

export const MsgImportMorseClaimableAccounts: MessageFns<MsgImportMorseClaimableAccounts> = {
  encode(message: MsgImportMorseClaimableAccounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.morseAccountState !== undefined) {
      MorseAccountState.encode(message.morseAccountState, writer.uint32(18).fork()).join();
    }
    if (message.morseAccountStateHash.length !== 0) {
      writer.uint32(26).bytes(message.morseAccountStateHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgImportMorseClaimableAccounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgImportMorseClaimableAccounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.morseAccountState = MorseAccountState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseAccountStateHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgImportMorseClaimableAccounts {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      morseAccountState: isSet(object.morseAccountState)
        ? MorseAccountState.fromJSON(object.morseAccountState)
        : undefined,
      morseAccountStateHash: isSet(object.morseAccountStateHash)
        ? bytesFromBase64(object.morseAccountStateHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgImportMorseClaimableAccounts): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.morseAccountState !== undefined) {
      obj.morseAccountState = MorseAccountState.toJSON(message.morseAccountState);
    }
    if (message.morseAccountStateHash.length !== 0) {
      obj.morseAccountStateHash = base64FromBytes(message.morseAccountStateHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgImportMorseClaimableAccounts>, I>>(base?: I): MsgImportMorseClaimableAccounts {
    return MsgImportMorseClaimableAccounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgImportMorseClaimableAccounts>, I>>(
    object: I,
  ): MsgImportMorseClaimableAccounts {
    const message = createBaseMsgImportMorseClaimableAccounts();
    message.authority = object.authority ?? "";
    message.morseAccountState = (object.morseAccountState !== undefined && object.morseAccountState !== null)
      ? MorseAccountState.fromPartial(object.morseAccountState)
      : undefined;
    message.morseAccountStateHash = object.morseAccountStateHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgImportMorseClaimableAccountsResponse(): MsgImportMorseClaimableAccountsResponse {
  return { stateHash: new Uint8Array(0), numAccounts: 0 };
}

export const MsgImportMorseClaimableAccountsResponse: MessageFns<MsgImportMorseClaimableAccountsResponse> = {
  encode(message: MsgImportMorseClaimableAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stateHash.length !== 0) {
      writer.uint32(10).bytes(message.stateHash);
    }
    if (message.numAccounts !== 0) {
      writer.uint32(16).uint64(message.numAccounts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgImportMorseClaimableAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgImportMorseClaimableAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stateHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numAccounts = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgImportMorseClaimableAccountsResponse {
    return {
      stateHash: isSet(object.stateHash) ? bytesFromBase64(object.stateHash) : new Uint8Array(0),
      numAccounts: isSet(object.numAccounts) ? globalThis.Number(object.numAccounts) : 0,
    };
  },

  toJSON(message: MsgImportMorseClaimableAccountsResponse): unknown {
    const obj: any = {};
    if (message.stateHash.length !== 0) {
      obj.stateHash = base64FromBytes(message.stateHash);
    }
    if (message.numAccounts !== 0) {
      obj.numAccounts = Math.round(message.numAccounts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgImportMorseClaimableAccountsResponse>, I>>(
    base?: I,
  ): MsgImportMorseClaimableAccountsResponse {
    return MsgImportMorseClaimableAccountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgImportMorseClaimableAccountsResponse>, I>>(
    object: I,
  ): MsgImportMorseClaimableAccountsResponse {
    const message = createBaseMsgImportMorseClaimableAccountsResponse();
    message.stateHash = object.stateHash ?? new Uint8Array(0);
    message.numAccounts = object.numAccounts ?? 0;
    return message;
  },
};

function createBaseMsgClaimMorseAccount(): MsgClaimMorseAccount {
  return {
    shannonSigningAddress: "",
    shannonDestAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
  };
}

export const MsgClaimMorseAccount: MessageFns<MsgClaimMorseAccount> = {
  encode(message: MsgClaimMorseAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(34).string(message.shannonSigningAddress);
    }
    if (message.shannonDestAddress !== "") {
      writer.uint32(10).string(message.shannonDestAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(42).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(26).bytes(message.morseSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonDestAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseAccount {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonDestAddress: isSet(object.shannonDestAddress) ? globalThis.String(object.shannonDestAddress) : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgClaimMorseAccount): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonDestAddress !== "") {
      obj.shannonDestAddress = message.shannonDestAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseAccount>, I>>(base?: I): MsgClaimMorseAccount {
    return MsgClaimMorseAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseAccount>, I>>(object: I): MsgClaimMorseAccount {
    const message = createBaseMsgClaimMorseAccount();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonDestAddress = object.shannonDestAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgClaimMorseAccountResponse(): MsgClaimMorseAccountResponse {
  return { morseSrcAddress: "", claimedBalance: undefined, sessionEndHeight: 0 };
}

export const MsgClaimMorseAccountResponse: MessageFns<MsgClaimMorseAccountResponse> = {
  encode(message: MsgClaimMorseAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.morseSrcAddress !== "") {
      writer.uint32(10).string(message.morseSrcAddress);
    }
    if (message.claimedBalance !== undefined) {
      Coin.encode(message.claimedBalance, writer.uint32(18).fork()).join();
    }
    if (message.sessionEndHeight !== 0) {
      writer.uint32(24).int64(message.sessionEndHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.morseSrcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimedBalance = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sessionEndHeight = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseAccountResponse {
    return {
      morseSrcAddress: isSet(object.morseSrcAddress) ? globalThis.String(object.morseSrcAddress) : "",
      claimedBalance: isSet(object.claimedBalance) ? Coin.fromJSON(object.claimedBalance) : undefined,
      sessionEndHeight: isSet(object.sessionEndHeight) ? globalThis.Number(object.sessionEndHeight) : 0,
    };
  },

  toJSON(message: MsgClaimMorseAccountResponse): unknown {
    const obj: any = {};
    if (message.morseSrcAddress !== "") {
      obj.morseSrcAddress = message.morseSrcAddress;
    }
    if (message.claimedBalance !== undefined) {
      obj.claimedBalance = Coin.toJSON(message.claimedBalance);
    }
    if (message.sessionEndHeight !== 0) {
      obj.sessionEndHeight = Math.round(message.sessionEndHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseAccountResponse>, I>>(base?: I): MsgClaimMorseAccountResponse {
    return MsgClaimMorseAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseAccountResponse>, I>>(object: I): MsgClaimMorseAccountResponse {
    const message = createBaseMsgClaimMorseAccountResponse();
    message.morseSrcAddress = object.morseSrcAddress ?? "";
    message.claimedBalance = (object.claimedBalance !== undefined && object.claimedBalance !== null)
      ? Coin.fromPartial(object.claimedBalance)
      : undefined;
    message.sessionEndHeight = object.sessionEndHeight ?? 0;
    return message;
  },
};

function createBaseMsgClaimMorseApplication(): MsgClaimMorseApplication {
  return {
    shannonSigningAddress: "",
    shannonDestAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
    serviceConfig: undefined,
  };
}

export const MsgClaimMorseApplication: MessageFns<MsgClaimMorseApplication> = {
  encode(message: MsgClaimMorseApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(42).string(message.shannonSigningAddress);
    }
    if (message.shannonDestAddress !== "") {
      writer.uint32(10).string(message.shannonDestAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(50).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(26).bytes(message.morseSignature);
    }
    if (message.serviceConfig !== undefined) {
      ApplicationServiceConfig.encode(message.serviceConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonDestAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceConfig = ApplicationServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseApplication {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonDestAddress: isSet(object.shannonDestAddress) ? globalThis.String(object.shannonDestAddress) : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
      serviceConfig: isSet(object.serviceConfig) ? ApplicationServiceConfig.fromJSON(object.serviceConfig) : undefined,
    };
  },

  toJSON(message: MsgClaimMorseApplication): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonDestAddress !== "") {
      obj.shannonDestAddress = message.shannonDestAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    if (message.serviceConfig !== undefined) {
      obj.serviceConfig = ApplicationServiceConfig.toJSON(message.serviceConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseApplication>, I>>(base?: I): MsgClaimMorseApplication {
    return MsgClaimMorseApplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseApplication>, I>>(object: I): MsgClaimMorseApplication {
    const message = createBaseMsgClaimMorseApplication();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonDestAddress = object.shannonDestAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    message.serviceConfig = (object.serviceConfig !== undefined && object.serviceConfig !== null)
      ? ApplicationServiceConfig.fromPartial(object.serviceConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgClaimMorseApplicationResponse(): MsgClaimMorseApplicationResponse {
  return {
    morseSrcAddress: "",
    claimedBalance: undefined,
    claimedApplicationStake: undefined,
    sessionEndHeight: 0,
    application: undefined,
  };
}

export const MsgClaimMorseApplicationResponse: MessageFns<MsgClaimMorseApplicationResponse> = {
  encode(message: MsgClaimMorseApplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.morseSrcAddress !== "") {
      writer.uint32(10).string(message.morseSrcAddress);
    }
    if (message.claimedBalance !== undefined) {
      Coin.encode(message.claimedBalance, writer.uint32(18).fork()).join();
    }
    if (message.claimedApplicationStake !== undefined) {
      Coin.encode(message.claimedApplicationStake, writer.uint32(26).fork()).join();
    }
    if (message.sessionEndHeight !== 0) {
      writer.uint32(32).int64(message.sessionEndHeight);
    }
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseApplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseApplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.morseSrcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimedBalance = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claimedApplicationStake = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sessionEndHeight = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseApplicationResponse {
    return {
      morseSrcAddress: isSet(object.morseSrcAddress) ? globalThis.String(object.morseSrcAddress) : "",
      claimedBalance: isSet(object.claimedBalance) ? Coin.fromJSON(object.claimedBalance) : undefined,
      claimedApplicationStake: isSet(object.claimedApplicationStake)
        ? Coin.fromJSON(object.claimedApplicationStake)
        : undefined,
      sessionEndHeight: isSet(object.sessionEndHeight) ? globalThis.Number(object.sessionEndHeight) : 0,
      application: isSet(object.application) ? Application.fromJSON(object.application) : undefined,
    };
  },

  toJSON(message: MsgClaimMorseApplicationResponse): unknown {
    const obj: any = {};
    if (message.morseSrcAddress !== "") {
      obj.morseSrcAddress = message.morseSrcAddress;
    }
    if (message.claimedBalance !== undefined) {
      obj.claimedBalance = Coin.toJSON(message.claimedBalance);
    }
    if (message.claimedApplicationStake !== undefined) {
      obj.claimedApplicationStake = Coin.toJSON(message.claimedApplicationStake);
    }
    if (message.sessionEndHeight !== 0) {
      obj.sessionEndHeight = Math.round(message.sessionEndHeight);
    }
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseApplicationResponse>, I>>(
    base?: I,
  ): MsgClaimMorseApplicationResponse {
    return MsgClaimMorseApplicationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseApplicationResponse>, I>>(
    object: I,
  ): MsgClaimMorseApplicationResponse {
    const message = createBaseMsgClaimMorseApplicationResponse();
    message.morseSrcAddress = object.morseSrcAddress ?? "";
    message.claimedBalance = (object.claimedBalance !== undefined && object.claimedBalance !== null)
      ? Coin.fromPartial(object.claimedBalance)
      : undefined;
    message.claimedApplicationStake =
      (object.claimedApplicationStake !== undefined && object.claimedApplicationStake !== null)
        ? Coin.fromPartial(object.claimedApplicationStake)
        : undefined;
    message.sessionEndHeight = object.sessionEndHeight ?? 0;
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    return message;
  },
};

function createBaseMsgClaimMorseSupplier(): MsgClaimMorseSupplier {
  return {
    shannonSigningAddress: "",
    shannonOwnerAddress: "",
    shannonOperatorAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
    services: [],
  };
}

export const MsgClaimMorseSupplier: MessageFns<MsgClaimMorseSupplier> = {
  encode(message: MsgClaimMorseSupplier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(50).string(message.shannonSigningAddress);
    }
    if (message.shannonOwnerAddress !== "") {
      writer.uint32(10).string(message.shannonOwnerAddress);
    }
    if (message.shannonOperatorAddress !== "") {
      writer.uint32(18).string(message.shannonOperatorAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(58).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(34).bytes(message.morseSignature);
    }
    for (const v of message.services) {
      SupplierServiceConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseSupplier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseSupplier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonOwnerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shannonOperatorAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.services.push(SupplierServiceConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseSupplier {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonOwnerAddress: isSet(object.shannonOwnerAddress) ? globalThis.String(object.shannonOwnerAddress) : "",
      shannonOperatorAddress: isSet(object.shannonOperatorAddress)
        ? globalThis.String(object.shannonOperatorAddress)
        : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => SupplierServiceConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgClaimMorseSupplier): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonOwnerAddress !== "") {
      obj.shannonOwnerAddress = message.shannonOwnerAddress;
    }
    if (message.shannonOperatorAddress !== "") {
      obj.shannonOperatorAddress = message.shannonOperatorAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => SupplierServiceConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseSupplier>, I>>(base?: I): MsgClaimMorseSupplier {
    return MsgClaimMorseSupplier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseSupplier>, I>>(object: I): MsgClaimMorseSupplier {
    const message = createBaseMsgClaimMorseSupplier();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonOwnerAddress = object.shannonOwnerAddress ?? "";
    message.shannonOperatorAddress = object.shannonOperatorAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    message.services = object.services?.map((e) => SupplierServiceConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgClaimMorseSupplierResponse(): MsgClaimMorseSupplierResponse {
  return {
    morseSrcAddress: "",
    claimedBalance: undefined,
    claimedSupplierStake: undefined,
    sessionEndHeight: 0,
    supplier: undefined,
  };
}

export const MsgClaimMorseSupplierResponse: MessageFns<MsgClaimMorseSupplierResponse> = {
  encode(message: MsgClaimMorseSupplierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.morseSrcAddress !== "") {
      writer.uint32(10).string(message.morseSrcAddress);
    }
    if (message.claimedBalance !== undefined) {
      Coin.encode(message.claimedBalance, writer.uint32(18).fork()).join();
    }
    if (message.claimedSupplierStake !== undefined) {
      Coin.encode(message.claimedSupplierStake, writer.uint32(26).fork()).join();
    }
    if (message.sessionEndHeight !== 0) {
      writer.uint32(32).int64(message.sessionEndHeight);
    }
    if (message.supplier !== undefined) {
      Supplier.encode(message.supplier, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseSupplierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseSupplierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.morseSrcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claimedBalance = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claimedSupplierStake = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sessionEndHeight = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.supplier = Supplier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseSupplierResponse {
    return {
      morseSrcAddress: isSet(object.morseSrcAddress) ? globalThis.String(object.morseSrcAddress) : "",
      claimedBalance: isSet(object.claimedBalance) ? Coin.fromJSON(object.claimedBalance) : undefined,
      claimedSupplierStake: isSet(object.claimedSupplierStake) ? Coin.fromJSON(object.claimedSupplierStake) : undefined,
      sessionEndHeight: isSet(object.sessionEndHeight) ? globalThis.Number(object.sessionEndHeight) : 0,
      supplier: isSet(object.supplier) ? Supplier.fromJSON(object.supplier) : undefined,
    };
  },

  toJSON(message: MsgClaimMorseSupplierResponse): unknown {
    const obj: any = {};
    if (message.morseSrcAddress !== "") {
      obj.morseSrcAddress = message.morseSrcAddress;
    }
    if (message.claimedBalance !== undefined) {
      obj.claimedBalance = Coin.toJSON(message.claimedBalance);
    }
    if (message.claimedSupplierStake !== undefined) {
      obj.claimedSupplierStake = Coin.toJSON(message.claimedSupplierStake);
    }
    if (message.sessionEndHeight !== 0) {
      obj.sessionEndHeight = Math.round(message.sessionEndHeight);
    }
    if (message.supplier !== undefined) {
      obj.supplier = Supplier.toJSON(message.supplier);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseSupplierResponse>, I>>(base?: I): MsgClaimMorseSupplierResponse {
    return MsgClaimMorseSupplierResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseSupplierResponse>, I>>(
    object: I,
  ): MsgClaimMorseSupplierResponse {
    const message = createBaseMsgClaimMorseSupplierResponse();
    message.morseSrcAddress = object.morseSrcAddress ?? "";
    message.claimedBalance = (object.claimedBalance !== undefined && object.claimedBalance !== null)
      ? Coin.fromPartial(object.claimedBalance)
      : undefined;
    message.claimedSupplierStake = (object.claimedSupplierStake !== undefined && object.claimedSupplierStake !== null)
      ? Coin.fromPartial(object.claimedSupplierStake)
      : undefined;
    message.sessionEndHeight = object.sessionEndHeight ?? 0;
    message.supplier = (object.supplier !== undefined && object.supplier !== null)
      ? Supplier.fromPartial(object.supplier)
      : undefined;
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  ImportMorseClaimableAccounts(
    request: MsgImportMorseClaimableAccounts,
  ): Promise<MsgImportMorseClaimableAccountsResponse>;
  ClaimMorseAccount(request: MsgClaimMorseAccount): Promise<MsgClaimMorseAccountResponse>;
  ClaimMorseApplication(request: MsgClaimMorseApplication): Promise<MsgClaimMorseApplicationResponse>;
  ClaimMorseSupplier(request: MsgClaimMorseSupplier): Promise<MsgClaimMorseSupplierResponse>;
}

export const MsgServiceName = "pocket.migration.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.ImportMorseClaimableAccounts = this.ImportMorseClaimableAccounts.bind(this);
    this.ClaimMorseAccount = this.ClaimMorseAccount.bind(this);
    this.ClaimMorseApplication = this.ClaimMorseApplication.bind(this);
    this.ClaimMorseSupplier = this.ClaimMorseSupplier.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  ImportMorseClaimableAccounts(
    request: MsgImportMorseClaimableAccounts,
  ): Promise<MsgImportMorseClaimableAccountsResponse> {
    const data = MsgImportMorseClaimableAccounts.encode(request).finish();
    const promise = this.rpc.request(this.service, "ImportMorseClaimableAccounts", data);
    return promise.then((data) => MsgImportMorseClaimableAccountsResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseAccount(request: MsgClaimMorseAccount): Promise<MsgClaimMorseAccountResponse> {
    const data = MsgClaimMorseAccount.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseAccount", data);
    return promise.then((data) => MsgClaimMorseAccountResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseApplication(request: MsgClaimMorseApplication): Promise<MsgClaimMorseApplicationResponse> {
    const data = MsgClaimMorseApplication.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseApplication", data);
    return promise.then((data) => MsgClaimMorseApplicationResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseSupplier(request: MsgClaimMorseSupplier): Promise<MsgClaimMorseSupplierResponse> {
    const data = MsgClaimMorseSupplier.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseSupplier", data);
    return promise.then((data) => MsgClaimMorseSupplierResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
