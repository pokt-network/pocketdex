// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: pocket/migration/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ApplicationServiceConfig, SupplierServiceConfig } from "../shared/service";
import { MorseAccountState } from "./morse_onchain";
import { Params } from "./params";

export const protobufPackage = "pocket.migration";

/**
 * MsgUpdateParams is the Msg/UpdateParams request type.
 *
 * - Used for updating the migration module parameters via governance
 * - All parameters must be supplied
 */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /**
   * Module parameters to update
   * NOTE: All parameters must be supplied
   */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a MsgUpdateParams message.
 *
 * - Empty response on success
 */
export interface MsgUpdateParamsResponse {
}

/**
 * MsgImportMorseClaimableAccounts is used to:
 *
 * - Create the on-chain MorseClaimableAccounts ONLY AND EXACTLY ONCE (per network / re-genesis)
 * - Import Morse account state derived from Morse state export
 */
export interface MsgImportMorseClaimableAccounts {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** Account state derived from Morse state export and `pocketd tx migration collect-morse-accounts` */
  morseAccountState:
    | MorseAccountState
    | undefined;
  /**
   * Validates the morse_account_state sha256 hash:
   * - Transaction fails if hash doesn't match on-chain computation
   * - Off-chain social consensus should be reached before verification
   *
   * Verification (high-level):
   *   $ pocketd tx migration collect-morse-accounts $<(pocket util export-genesis-for-reset)
   *
   * Additional docs:
   *   - pocket util export-genesis-for-migration --help
   *   - pocketd tx migration collect-morse-accounts --help
   */
  morseAccountStateHash: Uint8Array;
}

/**
 * MsgImportMorseClaimableAccountsResponse is returned from MsgImportMorseClaimableAccounts.
 *
 * - Indicates the canonical hash of the imported MorseAccountState
 * - Reports the number of claimable accounts imported
 */
export interface MsgImportMorseClaimableAccountsResponse {
}

/**
 * MsgClaimMorseAccount is used to:
 *
 * - Execute a claim (one-time minting of tokens on Shannon)
 * - Claim the balance of a given Morse account per on-chain MorseClaimableAccounts
 * - Mint claimed balance to the given Shannon account
 *
 * NOTE:
 * - A transaction can contain ONE OR MORE Morse account/actor claim messages AND has EXACTLY ONE signer.
 * - The Shannon account specified must be the message signer
 * - Authz grants MAY be used to delegate claiming authority to other Shannon accounts
 */
export interface MsgClaimMorseAccount {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving.
   */
  shannonSigningAddress: string;
  /** The bech32-encoded address of the Shannon account to which the claimed balance will be minted. */
  shannonDestAddress: string;
  /** The ed25519 public key of the morse account with morse_src_address. */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, by the Morse account, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
   */
  morseSignature: Uint8Array;
}

/**
 * MsgClaimMorseAccountResponse is returned from MsgClaimMorseAccount.
 *
 * - Indicates the morse_src_address of the claimed account
 * - Reports the claimed balance and commit height
 */
export interface MsgClaimMorseAccountResponse {
}

/**
 * MsgClaimMorseApplication is used to:
 *
 * - Execute a claim (one-time minting of tokens on Shannon) of total tokens owned by a Morse account
 * - Mint claimed tokens to the given Shannon account
 * - Stake that Shannon account as an application for the given service_config and same stake amount
 */
export interface MsgClaimMorseApplication {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
   * claim messages AND has EXACTLY ONE signer.
   */
  shannonSigningAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which the claimed tokens
   * will be minted and from which the application will be staked.
   */
  shannonDestAddress: string;
  /** The ed25519 public key of the morse account with morse_src_address. */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, by the Morse account, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
   */
  morseSignature: Uint8Array;
  /**
   * The services this application is staked to request service for.
   * NOTE: This is not a repeated field, as in MsgStakeApplication,
   * because an application can only be staked for one service.
   */
  serviceConfig: ApplicationServiceConfig | undefined;
}

/**
 * MsgClaimMorseApplicationResponse is returned from MsgClaimMorseApplication.
 *
 * - Indicates the morse_src_address of the claimed account
 * - Reports the unstaked balance claimed, application stake, and commit height
 * - Returns the staked application
 */
export interface MsgClaimMorseApplicationResponse {
}

/**
 * MsgClaimMorseSupplier is used to:
 *
 * - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
 * - Use the on-chain MorseClaimableAccounts for verification
 * - Credit the minted tokens to the balance of the given Shannon account
 * - Automatically stake that Shannon account as a supplier
 *
 * NOTE: The supplier module's staking fee parameter (at the time of claiming) is deducted from the claimed balance
 */
export interface MsgClaimMorseSupplier {
  /**
   * The bech32-encoded address of the Shannon account which is signing for this message.
   * This account is liable for any fees incurred by violating the constraints of Morse
   * account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
   * claim messages AND has EXACTLY ONE signer.
   */
  shannonSigningAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which the claimed tokens
   * will be minted and which become the supplier owner.
   * See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
   */
  shannonOwnerAddress: string;
  /**
   * The bech32-encoded address of the Shannon account to which will become the supplier operator.
   * If empty, the shannon_owner_address will be used.
   * See: https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.
   */
  shannonOperatorAddress: string;
  /**
   * The hex-encoded address of the Morse non-custodial (i.e. operator) account.
   * - Unstaked balance will be migrated 1:1
   * - Stake will be migrated 1:1 from morse_node_address to shannon_operator_address
   * - Morse non-custodial (i.e. operator) address.
   * If morse_output_address is not set, this is the custodial address.
   * - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
   * E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
   */
  morseNodeAddress: string;
  /**
   * The ed25519 public key of EITHER the Morse node/supplier operator OR owner account.
   * - MUST correspond to the private key which was used to produce the morse_signature.
   * - MUST correspond to ONE OF THE FOLLOWING:
   *   - morse_node_address
   *   - morse_output_address
   */
  morsePublicKey: Uint8Array;
  /**
   * The hex-encoded signature, of this message (where this field is nil).
   * I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseSupplier{morse_signature: nil, ...}))
   * - MUST match morse_public_key.
   * - MUST be signed by ONE OF THE FOLLOWING:
   *   - Morse node account (i.e. operator); if signer_is_output_address is false
   *   - Morse output account (i.e. owner); if signer_is_output_address is true
   */
  morseSignature: Uint8Array;
  /**
   * Set to true if the private key corresponding to the morse_output_address is producing the morse_signature.
   * For non-custodial claiming:
   * - This MUST be true.
   * - The morse_public_key MUST correspond to morse_output_address.
   * - The morse_signature MUST correspond to morse_output_address.
   */
  signerIsOutputAddress: boolean;
  /** The services this supplier is staked to provide service for. */
  services: SupplierServiceConfig[];
}

/**
 * MsgClaimMorseSupplierResponse is returned from MsgClaimMorseSupplier.
 *
 * - Indicates the morse_operator_address of the claimed account
 * - Reports the unstaked balance claimed, session end height, and staked supplier
 * - Includes claim signer type and signer address
 */
export interface MsgClaimMorseSupplierResponse {
}

/**
 * MsgRecoverMorseAccount is used to:
 *
 * - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
 * - Credit the minted tokens to the balance of the given Shannon account
 * - Migrate unclaimable staked and liquid Morse tokens as liquid Shannon tokens
 *
 * - MAY ONLY be executed by the authority
 * - ONLY intended for use on accounts with invalid addresses and/or known lost private keys
 */
export interface MsgRecoverMorseAccount {
  /**
   * The bech32-encoded address of the migration module authority account ("gov" module address by default).
   * ONLY the authority, or its delegates, MAY recover Morse recoverable accounts.
   */
  authority: string;
  /**
   * The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
   * balance(s) will be minted (recovered) as liquid Shannon tokens.
   */
  shannonDestAddress: string;
  /**
   * EITHER:
   * - The hex-encoded address of the recoverable Morse account whose stake(s) and/or balance(s) will be recovered.
   *   This address MAY be invalid but NEVER empty.
   *   E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
   * - The name of a Morse module account whose balance will be recovered.
   *   E.g. "dao" or "fee-collector"
   */
  morseSrcAddress: string;
}

/**
 * MsgRecoverMorseAccountResponse is returned from MsgRecoverMorseAccount.
 *
 * - Indicates the morse_src_address of the recovered account
 * - Reports the sum of any actor stakes and unstaked balance recovered
 * - Reports the session end height in which the recovery was committed
 * - Returns the destination Shannon address
 */
export interface MsgRecoverMorseAccountResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgImportMorseClaimableAccounts(): MsgImportMorseClaimableAccounts {
  return { authority: "", morseAccountState: undefined, morseAccountStateHash: new Uint8Array(0) };
}

export const MsgImportMorseClaimableAccounts: MessageFns<MsgImportMorseClaimableAccounts> = {
  encode(message: MsgImportMorseClaimableAccounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.morseAccountState !== undefined) {
      MorseAccountState.encode(message.morseAccountState, writer.uint32(18).fork()).join();
    }
    if (message.morseAccountStateHash.length !== 0) {
      writer.uint32(26).bytes(message.morseAccountStateHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgImportMorseClaimableAccounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgImportMorseClaimableAccounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.morseAccountState = MorseAccountState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseAccountStateHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgImportMorseClaimableAccounts {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      morseAccountState: isSet(object.morseAccountState)
        ? MorseAccountState.fromJSON(object.morseAccountState)
        : undefined,
      morseAccountStateHash: isSet(object.morseAccountStateHash)
        ? bytesFromBase64(object.morseAccountStateHash)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgImportMorseClaimableAccounts): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.morseAccountState !== undefined) {
      obj.morseAccountState = MorseAccountState.toJSON(message.morseAccountState);
    }
    if (message.morseAccountStateHash.length !== 0) {
      obj.morseAccountStateHash = base64FromBytes(message.morseAccountStateHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgImportMorseClaimableAccounts>, I>>(base?: I): MsgImportMorseClaimableAccounts {
    return MsgImportMorseClaimableAccounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgImportMorseClaimableAccounts>, I>>(
    object: I,
  ): MsgImportMorseClaimableAccounts {
    const message = createBaseMsgImportMorseClaimableAccounts();
    message.authority = object.authority ?? "";
    message.morseAccountState = (object.morseAccountState !== undefined && object.morseAccountState !== null)
      ? MorseAccountState.fromPartial(object.morseAccountState)
      : undefined;
    message.morseAccountStateHash = object.morseAccountStateHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgImportMorseClaimableAccountsResponse(): MsgImportMorseClaimableAccountsResponse {
  return {};
}

export const MsgImportMorseClaimableAccountsResponse: MessageFns<MsgImportMorseClaimableAccountsResponse> = {
  encode(_: MsgImportMorseClaimableAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgImportMorseClaimableAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgImportMorseClaimableAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgImportMorseClaimableAccountsResponse {
    return {};
  },

  toJSON(_: MsgImportMorseClaimableAccountsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgImportMorseClaimableAccountsResponse>, I>>(
    base?: I,
  ): MsgImportMorseClaimableAccountsResponse {
    return MsgImportMorseClaimableAccountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgImportMorseClaimableAccountsResponse>, I>>(
    _: I,
  ): MsgImportMorseClaimableAccountsResponse {
    const message = createBaseMsgImportMorseClaimableAccountsResponse();
    return message;
  },
};

function createBaseMsgClaimMorseAccount(): MsgClaimMorseAccount {
  return {
    shannonSigningAddress: "",
    shannonDestAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
  };
}

export const MsgClaimMorseAccount: MessageFns<MsgClaimMorseAccount> = {
  encode(message: MsgClaimMorseAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(34).string(message.shannonSigningAddress);
    }
    if (message.shannonDestAddress !== "") {
      writer.uint32(10).string(message.shannonDestAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(42).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(26).bytes(message.morseSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonDestAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseAccount {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonDestAddress: isSet(object.shannonDestAddress) ? globalThis.String(object.shannonDestAddress) : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgClaimMorseAccount): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonDestAddress !== "") {
      obj.shannonDestAddress = message.shannonDestAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseAccount>, I>>(base?: I): MsgClaimMorseAccount {
    return MsgClaimMorseAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseAccount>, I>>(object: I): MsgClaimMorseAccount {
    const message = createBaseMsgClaimMorseAccount();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonDestAddress = object.shannonDestAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgClaimMorseAccountResponse(): MsgClaimMorseAccountResponse {
  return {};
}

export const MsgClaimMorseAccountResponse: MessageFns<MsgClaimMorseAccountResponse> = {
  encode(_: MsgClaimMorseAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgClaimMorseAccountResponse {
    return {};
  },

  toJSON(_: MsgClaimMorseAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseAccountResponse>, I>>(base?: I): MsgClaimMorseAccountResponse {
    return MsgClaimMorseAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseAccountResponse>, I>>(_: I): MsgClaimMorseAccountResponse {
    const message = createBaseMsgClaimMorseAccountResponse();
    return message;
  },
};

function createBaseMsgClaimMorseApplication(): MsgClaimMorseApplication {
  return {
    shannonSigningAddress: "",
    shannonDestAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
    serviceConfig: undefined,
  };
}

export const MsgClaimMorseApplication: MessageFns<MsgClaimMorseApplication> = {
  encode(message: MsgClaimMorseApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(42).string(message.shannonSigningAddress);
    }
    if (message.shannonDestAddress !== "") {
      writer.uint32(10).string(message.shannonDestAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(50).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(26).bytes(message.morseSignature);
    }
    if (message.serviceConfig !== undefined) {
      ApplicationServiceConfig.encode(message.serviceConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonDestAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceConfig = ApplicationServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseApplication {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonDestAddress: isSet(object.shannonDestAddress) ? globalThis.String(object.shannonDestAddress) : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
      serviceConfig: isSet(object.serviceConfig) ? ApplicationServiceConfig.fromJSON(object.serviceConfig) : undefined,
    };
  },

  toJSON(message: MsgClaimMorseApplication): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonDestAddress !== "") {
      obj.shannonDestAddress = message.shannonDestAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    if (message.serviceConfig !== undefined) {
      obj.serviceConfig = ApplicationServiceConfig.toJSON(message.serviceConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseApplication>, I>>(base?: I): MsgClaimMorseApplication {
    return MsgClaimMorseApplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseApplication>, I>>(object: I): MsgClaimMorseApplication {
    const message = createBaseMsgClaimMorseApplication();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonDestAddress = object.shannonDestAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    message.serviceConfig = (object.serviceConfig !== undefined && object.serviceConfig !== null)
      ? ApplicationServiceConfig.fromPartial(object.serviceConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgClaimMorseApplicationResponse(): MsgClaimMorseApplicationResponse {
  return {};
}

export const MsgClaimMorseApplicationResponse: MessageFns<MsgClaimMorseApplicationResponse> = {
  encode(_: MsgClaimMorseApplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseApplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseApplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgClaimMorseApplicationResponse {
    return {};
  },

  toJSON(_: MsgClaimMorseApplicationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseApplicationResponse>, I>>(
    base?: I,
  ): MsgClaimMorseApplicationResponse {
    return MsgClaimMorseApplicationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseApplicationResponse>, I>>(
    _: I,
  ): MsgClaimMorseApplicationResponse {
    const message = createBaseMsgClaimMorseApplicationResponse();
    return message;
  },
};

function createBaseMsgClaimMorseSupplier(): MsgClaimMorseSupplier {
  return {
    shannonSigningAddress: "",
    shannonOwnerAddress: "",
    shannonOperatorAddress: "",
    morseNodeAddress: "",
    morsePublicKey: new Uint8Array(0),
    morseSignature: new Uint8Array(0),
    signerIsOutputAddress: false,
    services: [],
  };
}

export const MsgClaimMorseSupplier: MessageFns<MsgClaimMorseSupplier> = {
  encode(message: MsgClaimMorseSupplier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shannonSigningAddress !== "") {
      writer.uint32(50).string(message.shannonSigningAddress);
    }
    if (message.shannonOwnerAddress !== "") {
      writer.uint32(10).string(message.shannonOwnerAddress);
    }
    if (message.shannonOperatorAddress !== "") {
      writer.uint32(18).string(message.shannonOperatorAddress);
    }
    if (message.morseNodeAddress !== "") {
      writer.uint32(26).string(message.morseNodeAddress);
    }
    if (message.morsePublicKey.length !== 0) {
      writer.uint32(58).bytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      writer.uint32(34).bytes(message.morseSignature);
    }
    if (message.signerIsOutputAddress !== false) {
      writer.uint32(64).bool(message.signerIsOutputAddress);
    }
    for (const v of message.services) {
      SupplierServiceConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseSupplier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseSupplier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.shannonSigningAddress = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shannonOwnerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shannonOperatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseNodeAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.morsePublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.morseSignature = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.signerIsOutputAddress = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.services.push(SupplierServiceConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimMorseSupplier {
    return {
      shannonSigningAddress: isSet(object.shannonSigningAddress) ? globalThis.String(object.shannonSigningAddress) : "",
      shannonOwnerAddress: isSet(object.shannonOwnerAddress) ? globalThis.String(object.shannonOwnerAddress) : "",
      shannonOperatorAddress: isSet(object.shannonOperatorAddress)
        ? globalThis.String(object.shannonOperatorAddress)
        : "",
      morseNodeAddress: isSet(object.morseNodeAddress) ? globalThis.String(object.morseNodeAddress) : "",
      morsePublicKey: isSet(object.morsePublicKey) ? bytesFromBase64(object.morsePublicKey) : new Uint8Array(0),
      morseSignature: isSet(object.morseSignature) ? bytesFromBase64(object.morseSignature) : new Uint8Array(0),
      signerIsOutputAddress: isSet(object.signerIsOutputAddress)
        ? globalThis.Boolean(object.signerIsOutputAddress)
        : false,
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => SupplierServiceConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgClaimMorseSupplier): unknown {
    const obj: any = {};
    if (message.shannonSigningAddress !== "") {
      obj.shannonSigningAddress = message.shannonSigningAddress;
    }
    if (message.shannonOwnerAddress !== "") {
      obj.shannonOwnerAddress = message.shannonOwnerAddress;
    }
    if (message.shannonOperatorAddress !== "") {
      obj.shannonOperatorAddress = message.shannonOperatorAddress;
    }
    if (message.morseNodeAddress !== "") {
      obj.morseNodeAddress = message.morseNodeAddress;
    }
    if (message.morsePublicKey.length !== 0) {
      obj.morsePublicKey = base64FromBytes(message.morsePublicKey);
    }
    if (message.morseSignature.length !== 0) {
      obj.morseSignature = base64FromBytes(message.morseSignature);
    }
    if (message.signerIsOutputAddress !== false) {
      obj.signerIsOutputAddress = message.signerIsOutputAddress;
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => SupplierServiceConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseSupplier>, I>>(base?: I): MsgClaimMorseSupplier {
    return MsgClaimMorseSupplier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseSupplier>, I>>(object: I): MsgClaimMorseSupplier {
    const message = createBaseMsgClaimMorseSupplier();
    message.shannonSigningAddress = object.shannonSigningAddress ?? "";
    message.shannonOwnerAddress = object.shannonOwnerAddress ?? "";
    message.shannonOperatorAddress = object.shannonOperatorAddress ?? "";
    message.morseNodeAddress = object.morseNodeAddress ?? "";
    message.morsePublicKey = object.morsePublicKey ?? new Uint8Array(0);
    message.morseSignature = object.morseSignature ?? new Uint8Array(0);
    message.signerIsOutputAddress = object.signerIsOutputAddress ?? false;
    message.services = object.services?.map((e) => SupplierServiceConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgClaimMorseSupplierResponse(): MsgClaimMorseSupplierResponse {
  return {};
}

export const MsgClaimMorseSupplierResponse: MessageFns<MsgClaimMorseSupplierResponse> = {
  encode(_: MsgClaimMorseSupplierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimMorseSupplierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimMorseSupplierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgClaimMorseSupplierResponse {
    return {};
  },

  toJSON(_: MsgClaimMorseSupplierResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgClaimMorseSupplierResponse>, I>>(base?: I): MsgClaimMorseSupplierResponse {
    return MsgClaimMorseSupplierResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgClaimMorseSupplierResponse>, I>>(_: I): MsgClaimMorseSupplierResponse {
    const message = createBaseMsgClaimMorseSupplierResponse();
    return message;
  },
};

function createBaseMsgRecoverMorseAccount(): MsgRecoverMorseAccount {
  return { authority: "", shannonDestAddress: "", morseSrcAddress: "" };
}

export const MsgRecoverMorseAccount: MessageFns<MsgRecoverMorseAccount> = {
  encode(message: MsgRecoverMorseAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.shannonDestAddress !== "") {
      writer.uint32(18).string(message.shannonDestAddress);
    }
    if (message.morseSrcAddress !== "") {
      writer.uint32(26).string(message.morseSrcAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRecoverMorseAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRecoverMorseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shannonDestAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.morseSrcAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRecoverMorseAccount {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      shannonDestAddress: isSet(object.shannonDestAddress) ? globalThis.String(object.shannonDestAddress) : "",
      morseSrcAddress: isSet(object.morseSrcAddress) ? globalThis.String(object.morseSrcAddress) : "",
    };
  },

  toJSON(message: MsgRecoverMorseAccount): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.shannonDestAddress !== "") {
      obj.shannonDestAddress = message.shannonDestAddress;
    }
    if (message.morseSrcAddress !== "") {
      obj.morseSrcAddress = message.morseSrcAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRecoverMorseAccount>, I>>(base?: I): MsgRecoverMorseAccount {
    return MsgRecoverMorseAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRecoverMorseAccount>, I>>(object: I): MsgRecoverMorseAccount {
    const message = createBaseMsgRecoverMorseAccount();
    message.authority = object.authority ?? "";
    message.shannonDestAddress = object.shannonDestAddress ?? "";
    message.morseSrcAddress = object.morseSrcAddress ?? "";
    return message;
  },
};

function createBaseMsgRecoverMorseAccountResponse(): MsgRecoverMorseAccountResponse {
  return {};
}

export const MsgRecoverMorseAccountResponse: MessageFns<MsgRecoverMorseAccountResponse> = {
  encode(_: MsgRecoverMorseAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRecoverMorseAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRecoverMorseAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRecoverMorseAccountResponse {
    return {};
  },

  toJSON(_: MsgRecoverMorseAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRecoverMorseAccountResponse>, I>>(base?: I): MsgRecoverMorseAccountResponse {
    return MsgRecoverMorseAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRecoverMorseAccountResponse>, I>>(_: I): MsgRecoverMorseAccountResponse {
    const message = createBaseMsgRecoverMorseAccountResponse();
    return message;
  },
};

/**
 * Msg defines the Msg service.
 *
 * - Provides RPCs for migration-related operations
 * - Includes parameter updates, Morse account claims, supplier claims, and recovery
 */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  ImportMorseClaimableAccounts(
    request: MsgImportMorseClaimableAccounts,
  ): Promise<MsgImportMorseClaimableAccountsResponse>;
  ClaimMorseAccount(request: MsgClaimMorseAccount): Promise<MsgClaimMorseAccountResponse>;
  ClaimMorseApplication(request: MsgClaimMorseApplication): Promise<MsgClaimMorseApplicationResponse>;
  ClaimMorseSupplier(request: MsgClaimMorseSupplier): Promise<MsgClaimMorseSupplierResponse>;
  RecoverMorseAccount(request: MsgRecoverMorseAccount): Promise<MsgRecoverMorseAccountResponse>;
}

export const MsgServiceName = "pocket.migration.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.ImportMorseClaimableAccounts = this.ImportMorseClaimableAccounts.bind(this);
    this.ClaimMorseAccount = this.ClaimMorseAccount.bind(this);
    this.ClaimMorseApplication = this.ClaimMorseApplication.bind(this);
    this.ClaimMorseSupplier = this.ClaimMorseSupplier.bind(this);
    this.RecoverMorseAccount = this.RecoverMorseAccount.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  ImportMorseClaimableAccounts(
    request: MsgImportMorseClaimableAccounts,
  ): Promise<MsgImportMorseClaimableAccountsResponse> {
    const data = MsgImportMorseClaimableAccounts.encode(request).finish();
    const promise = this.rpc.request(this.service, "ImportMorseClaimableAccounts", data);
    return promise.then((data) => MsgImportMorseClaimableAccountsResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseAccount(request: MsgClaimMorseAccount): Promise<MsgClaimMorseAccountResponse> {
    const data = MsgClaimMorseAccount.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseAccount", data);
    return promise.then((data) => MsgClaimMorseAccountResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseApplication(request: MsgClaimMorseApplication): Promise<MsgClaimMorseApplicationResponse> {
    const data = MsgClaimMorseApplication.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseApplication", data);
    return promise.then((data) => MsgClaimMorseApplicationResponse.decode(new BinaryReader(data)));
  }

  ClaimMorseSupplier(request: MsgClaimMorseSupplier): Promise<MsgClaimMorseSupplierResponse> {
    const data = MsgClaimMorseSupplier.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimMorseSupplier", data);
    return promise.then((data) => MsgClaimMorseSupplierResponse.decode(new BinaryReader(data)));
  }

  RecoverMorseAccount(request: MsgRecoverMorseAccount): Promise<MsgRecoverMorseAccountResponse> {
    const data = MsgRecoverMorseAccount.encode(request).finish();
    const promise = this.rpc.request(this.service, "RecoverMorseAccount", data);
    return promise.then((data) => MsgRecoverMorseAccountResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
