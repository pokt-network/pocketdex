# To improve query performance, we strongly suggest adding indexes to any field that you plan to filter or sort by
# Add the `@index` or `@index(unique: true)` annotation after any non-key field
# https://academy.subquery.network/build/graphql.html#indexing-by-non-primary-key-field

type EventAttribute @entity {
  id: ID!
  key: String!
  value: String!
  event: Event!
}

type Block @entity {
  id: ID! # The block header hash
  chainId: String! @index
  height: BigInt! @index
  timestamp: Date!
  transactions: [Transaction] @derivedFrom(field: "block")
  messages: [Message] @derivedFrom(field: "block")
  events: [Event] @derivedFrom(field: "block")
  balancesOfAccountByDenom: [Balance] @derivedFrom(field: "lastUpdatedBlock")
  # PARAMS
  appParams: [AppParam] @derivedFrom(field: "block")
  authParams: [AuthParam] @derivedFrom(field: "block")
  bankParams: [BankParam] @derivedFrom(field: "block")
  distributionParams: [DistributionParam] @derivedFrom(field: "block")
  gatewayParams: [GatewayParam] @derivedFrom(field: "block")
  govParams: [GovParam] @derivedFrom(field: "block")
  mintParams: [MintParam] @derivedFrom(field: "block")
  proofParams: [ProofParam] @derivedFrom(field: "block")
  serviceParams: [ServiceParam] @derivedFrom(field: "block")
  sessionParams: [SessionParam] @derivedFrom(field: "block")
  sharedParams: [SharedParam] @derivedFrom(field: "block")
  slashingParams: [SlashingParam] @derivedFrom(field: "block")
  stakingParams: [StakingParam] @derivedFrom(field: "block")
  supplierParams: [SupplierParam] @derivedFrom(field: "block")
  tokenomicsParams: [TokenomicsParam] @derivedFrom(field: "block")
  consensusParams: [ConsensusParam] @derivedFrom(field: "block")
}

type Transaction @entity {
  id: ID!
  block: Block!
  gasUsed: BigInt!
  gasWanted: BigInt!
  fees: [Coin]!
  memo: String
  # 0 = Success, 1 = Error
  status: Int!
  log: String
  timeoutHeight: BigInt @index
  # NB: only the first signer!
  signerAddress: String @index
  messages: [Message] @derivedFrom(field: "transaction")
}

type Message @entity {
  id: ID!
  typeUrl: String! @index
  json: String
  transaction: Transaction!
  block: Block!
}

type Event @entity {
  id: ID!
  type: String! @index
  attributes: [EventAttribute]! @derivedFrom(field: "event")
  transaction: Transaction
  block: Block!
}

type Coin @jsonField {
  denom: String!
  amount: String!
}

type NativeTransfer @entity {
  id: ID!
  toAddress: String! @index
  fromAddress: String! @index
  amounts: [Coin]!
  denom: String! @index
  message: Message!
  transaction: Transaction!
  block: Block!
}

type Account @entity {
  # id is the address
  id: ID!
  chainId: String! @index
  nativeBalanceChanges: [NativeBalanceChange]! @derivedFrom(field: "account")
  genesisBalances: [GenesisBalance] @derivedFrom(field: "account")
  balances: [Balance] @derivedFrom(field: "account")
  services: [Service] @derivedFrom(field: "owner")
}

type GenesisBalance @entity {
  id: ID!
  amount: BigInt!
  denom: String! @index
  account: Account!
}

type NativeBalanceChange @entity {
  id: ID!
  balanceOffset: BigInt!
  denom: String! @index
  account: Account!
  event: Event!
  transaction: Transaction
  block: Block!
}

type UnprocessedEntity @entity {
  id: ID!
  error: String!
  event: Event
  message: Message
  transaction: Transaction
  block: Block
}

type Service @entity {
  id: ID!
  name: String!
  computeUnitsPerRelay: BigInt!
  owner: Account!
  addServiceMsgs: [AddServiceMsg] @derivedFrom(field: "service")
}

type AppStakeMsg @entity {
  id: ID!
  stake: Coin!
  transaction: Transaction!
  block: Block!
  application: Application! @index
}

type AppStakeMsgService @entity {
  id: ID!
  appStakeMsg: AppStakeMsg!
  service: Service!
}

type AppUnstakeMsg @entity {
  id: ID!
  application: Application! @index
  transaction: Transaction!
  block: Block!
}

type DelegateToGatewayMsg @entity {
  id: ID!
  application: Application! @index
  gateway: Gateway! @index
  transaction: Transaction!
  block: Block!
}

type UndelegateToGatewayMsg @entity {
  id: ID!
  application: Application! @index
  gateway: Gateway! @index
  transaction: Transaction!
  block: Block!
}

type TransferApplicationMsg @entity {
  id: ID!
  sourceApplication: Application! @index
  destinationApplication: Application! @index
  transaction: Transaction!
  block: Block!
}

type Application @entity {
  # id is the address
  id: ID!
  account: Account!
  stake: Coin!
  # 0 = Staked, 1 = Unstaking, 2 = Unstaked
  status: Int!
  # Block where the msg to unstake the application was received
  unstakingStartBlock: Block
  # Height of the block where the application is going to be unstaked/unbonded. Received with the EventApplicationUnbondingBegin event.
  unstakingHeight: BigInt
  # Reason for the application to be unstaked/unbonded. Received with the EventApplicationUnbondingBegin event.
  # 0 = ELECTIVE, 1 = BELOW_MIN_STAKE, 2 = TRANSFERRED
  unstakingReason: Int
  # Block where the application was unstaked/unbonded. Received with the EventApplicationUnbondingEnd event.
  unstakedAtBlock: Block
  stakeMsgs: [AppStakeMsg] @derivedFrom(field: "application")
  unstakeMsgs: [AppUnstakeMsg] @derivedFrom(field: "application")
  delegateMsgs: [DelegateToGatewayMsg] @derivedFrom(field: "application")
  undelegateMsgs: [UndelegateToGatewayMsg] @derivedFrom(field: "application")
  sourceTransferMsgs: [TransferApplicationMsg] @derivedFrom(field: "sourceApplication")
  destinationTransferMsgs: [TransferApplicationMsg] @derivedFrom(field: "destinationApplication")
  sourceTransferBeginEvents: [TransferApplicationBeginEvent] @derivedFrom(field: "source")
  destinationTransferBeginEvents: [TransferApplicationBeginEvent] @derivedFrom(field: "destination")
  sourceTransferEndEvents: [TransferApplicationEndEvent] @derivedFrom(field: "source")
  destinationTransferEndEvents: [TransferApplicationEndEvent] @derivedFrom(field: "destination")
  sourceTransferErrorEvents: [TransferApplicationErrorEvent] @derivedFrom(field: "source")
  destinationTransferErrorEvents: [TransferApplicationErrorEvent] @derivedFrom(field: "destination")
  unstakingBeginEvents: [ApplicationUnbondingBeginEvent] @derivedFrom(field: "application")
  unstakingEndEvents: [ApplicationUnbondingEndEvent] @derivedFrom(field: "application")
  transferredFromAt: Block
  transferFrom: Application
  transferTo: Application
  transferToEndedAt: Block
  # Account because we don't know if the destination is an application
  transferringTo: Account
  transferEndsAtHeight: BigInt
}

type ApplicationDelegatedToGateway @entity {
  id: ID!
  gateway: Gateway!
  application: Application!
}

type ApplicationService @entity {
  id: ID!
  application: Application!
  service: Service!
}

type TransferApplicationBeginEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  source: Application!
  destination: Application!
  transaction: Transaction!
  block: Block!
}

type TransferApplicationEndEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  source: Application!
  destination: Application!
  transaction: Transaction
  block: Block!
}

type TransferApplicationErrorEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  source: Application!
  destination: Account!
  error: String!
  transaction: Transaction
  block: Block!
}

type ApplicationUnbondingBeginEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  application: Application!
  # 0 = ELECTIVE, 1 = BELOW_MIN_STAKE, 2 = TRANSFERRED
  reason: Int!
  sessionEndHeight: BigInt!
  unstakingEndHeight: BigInt!
  transaction: Transaction
  block: Block!
}

type ApplicationUnbondingEndEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  application: Application!
  # 0 = ELECTIVE, 1 = BELOW_MIN_STAKE, 2 = TRANSFERRED
  reason: Int!
  sessionEndHeight: BigInt!
  unstakingEndHeight: BigInt!
  transaction: Transaction
  block: Block!
}

type Balance @entity {
  id: ID!
  account: Account! @index
  denom: String! @index
  amount: BigInt!
  lastUpdatedBlock: Block!
}

type GenesisFile @entity {
  # id is the initial height
  id: ID!
  raw: String!
}

type SupplierStakeMsg @entity {
  id: ID!
  signer: Account!
  supplier: Supplier!
  owner: Account!
  stake: Coin!
  block: Block!
  transaction: Transaction!
}

type SupplierStakeMsgService @entity {
  id: ID!
  supplierStakeMsg: SupplierStakeMsg!
  service: Service!
  revShare: [SupplierRevShare]!
  endpoints: [SupplierEndpoint]!
}

type SupplierUnstakeMsg @entity {
  id: ID!
  signer: Account!
  supplier: Supplier!
  block: Block!
  transaction: Transaction!
}

type Supplier @entity {
  id: ID!
  operator: Account!
  owner: Account!
  stake: Coin!
  stakeMsgs: [SupplierStakeMsg] @derivedFrom(field: "supplier")
  unstakeMsgs: [SupplierUnstakeMsg] @derivedFrom(field: "supplier")
  unstakingBeginEvents: [SupplierUnbondingBeginEvent] @derivedFrom(field: "supplier")
  unstakingEndEvents: [SupplierUnbondingEndEvent] @derivedFrom(field: "supplier")
  # 0 = Staked, 1 = Unstaking, 2 = Unstaked
  status: Int!
  # Block where MsgUnstakeSupplier was received
  unstakingStartBlock: Block
  # Height of the block where the supplier is going to be unstaked/unbonded.
  # This is received with the EventSupplierUnbondingBegin event.
  unstakingHeight: BigInt
  # Block where the supplier was unstaked/unbonded.
  # This is received with the EventSupplierUnbondingEnd event.
  unstakedAtBlock: Block
}

type ConfigOption @jsonField {
  key: Int!
  value: String!
}

type SupplierEndpoint @jsonField {
  url: String!
  rpcType: Int!
  configs: [ConfigOption]!
}

type SupplierRevShare @jsonField {
  address: String!
  revSharePercentage: Float!
}

type SupplierService @entity {
  id: ID!
  supplier: Supplier!
  service: Service!
  revShare: [SupplierRevShare]!
  endpoints: [SupplierEndpoint]!
}

type SupplierUnbondingBeginEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  supplier: Supplier!
  block: Block!
  transaction: Transaction!
}

type SupplierUnbondingEndEvent @entity {
  # The ID of the event result of getEventId(event)
  id: ID!
  supplier: Supplier!
  block: Block!
}

type AddServiceMsg @entity {
  id: ID!
  service: Service!
  name: String!
  computeUnitsPerRelay: BigInt!
  owner: Account!
}

type Gateway @entity {
  id: ID!
  account: Account!
  stake: Coin!
  # 0 = Staked, 1 = Unstaking, 2 = Unstaked
  status: Int!
  unstakingStartBlock: Block
  unstakedAtBlock: Block
  stakeMsgs: [GatewayStakeMsg] @derivedFrom(field: "gateway")
  unstakeMsgs: [GatewayUnstakeMsg] @derivedFrom(field: "gateway")
  unstakedEvents: [GatewayUnstakedEvent] @derivedFrom(field: "gateway")
}

type GatewayStakeMsg @entity {
  id: ID!
  gateway: Gateway!
  stake: Coin!
  transaction: Transaction!
  block: Block!
}

type GatewayUnstakeMsg @entity {
  id: ID!
  gateway: Gateway!
  transaction: Transaction!
  block: Block!
}

type GatewayUnstakedEvent @entity {
  id: ID!
  gateway: Gateway!
  transaction: Transaction!
  block: Block!
}

# PARAMS

type AppParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type AuthParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type BankParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type DistributionParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type GatewayParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type GovParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type MintParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type ProofParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type ServiceParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type SessionParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type SharedParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type SlashingParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type StakingParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type SupplierParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type TokenomicsParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type ConsensusParam @entity {
  id: ID!
  key: String! @index
  value: String!
  block: Block!
}

type AuthzExec @entity {
  id: ID!
  grantee: String! @index
  subMessages: [AuthzExecMessage]! @derivedFrom(field: "authzExec")
  message: Message!
  transaction: Transaction!
  block: Block!
}

# NB: AuthzExec --|{ Message join table
type AuthzExecMessage @entity {
  id: ID!
  authzExec: AuthzExec!
  message: Message!
}
